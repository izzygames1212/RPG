<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D RPG with Fireball Powers</title>
<style>
  body {
    margin: 0; overflow: hidden; font-family: monospace; background-color: #000;
  }
  #log {
    position: absolute; top: 10px; left: 10px;
    background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px;
    max-width: 300px; font-size: 14px; color: white; z-index: 1;
  }
  #miniMap {
    position: absolute; top: 10px; right: 10px; border: 2px solid white;
    width: 150px; height: 150px; background: rgba(0,0,0,0.7); border-radius: 10px;
    z-index: 2;
  }
</style>
</head>
<body>
<div id="log">Use WASD to move, Space to shoot fireball</div>
<canvas id="miniMap"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
  // Scene, camera, renderer
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xaad0ff);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 8, 10);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Load textures for ground
  const loaderTex = new THREE.TextureLoader();
  const groundTexture = loaderTex.load("https://i.imgur.com/OZ0G7D0.jpg");
  groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
  groundTexture.repeat.set(10, 10);

  // Ground
  const groundMat = new THREE.MeshPhongMaterial({map: groundTexture});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Animated Water
  const waterGeometry = new THREE.PlaneGeometry(30,30, 32,32);
  const waterMaterial = new THREE.MeshPhongMaterial({
    color: 0x4fc3f7,
    transparent: true,
    opacity: 0.7,
    side: THREE.DoubleSide,
    shininess: 100,
  });
  const water = new THREE.Mesh(waterGeometry, waterMaterial);
  water.rotation.x = -Math.PI/2;
  water.position.set(20, 0.01, -20);
  scene.add(water);

  // Simple water animation variables
  const waterVertices = water.geometry.attributes.position.array;

  // Player and enemies
  let player, playerHealth = 100, playerMaxHealth = 100;
  let enemies = [];
  const enemyCount = 5;

  // Fireballs
  let fireballs = [];

  // GLTF Loader for player model (placeholder)
  const gltfLoader = new THREE.GLTFLoader();

  // Load player model ("The 67 Kid" placeholder)
  gltfLoader.load(
    'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
    (gltf) => {
      player = gltf.scene;
      player.scale.set(1.5,1.5,1.5);
      player.position.set(0,0,0);
      scene.add(player);
      playerHealth = 120;
      playerMaxHealth = 120;
    },
    undefined,
    (error) => {
      console.error('Error loading player model:', error);
      // fallback: simple box
      const mat = new THREE.MeshPhongMaterial({color: 0x2196f3});
      player = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
      player.position.set(0,1,0);
      scene.add(player);
    }
  );

  // Create enemies (red cubes)
  function spawnEnemies() {
    for(let i=0; i<enemyCount; i++) {
      const enemyMat = new THREE.MeshPhongMaterial({color: 0xff5252});
      const enemy = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), enemyMat);
      enemy.position.set(
        (Math.random()-0.5)*40,
        1,
        (Math.random()-0.5)*40
      );
      enemy.health = 50;
      enemy.maxHealth = 50;
      scene.add(enemy);
      enemies.push(enemy);
    }
  }
  spawnEnemies();

  // Movement controls
  const keys = {};
  document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
  document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

  // Fireball class
  class Fireball {
    constructor(position, direction) {
      const geometry = new THREE.SphereGeometry(0.2, 16, 16);
      const material = new THREE.MeshBasicMaterial({color: 0xff4500, emissive: 0xff2200});
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(position);
      this.direction = direction.clone().normalize();
      this.speed = 0.5;
      this.lifeTime = 200; // frames
      scene.add(this.mesh);
    }
    update() {
      this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed));
      this.lifeTime--;
      if (this.lifeTime <= 0) {
        this.destroy();
        return false;
      }
      return true;
    }
    destroy() {
      scene.remove(this.mesh);
    }
  }

  // Health bar helper
  function createHealthBar(maxHP) {
    const bar = document.createElement('div');
    bar.style.position = 'absolute';
    bar.style.backgroundColor = 'red';
    bar.style.height = '6px';
    bar.style.width = '100%';
    bar.style.borderRadius = '3px';
    const barContainer = document.createElement('div');
    barContainer.style.position = 'absolute';
    barContainer.style.width = '40px';
    barContainer.style.height = '6px';
    barContainer.style.backgroundColor = '#444';
    barContainer.style.borderRadius = '3px';
    barContainer.appendChild(bar);
    document.body.appendChild(barContainer);
    return {container: barContainer, bar: bar};
  }

  // Player health bar
  const playerHealthBar = createHealthBar(playerMaxHealth);

  // Enemies health bars
  const enemyHealthBars = enemies.map(() => createHealthBar(50));

  // Mini-map setup
  const miniMap = document.getElementById('miniMap');
  const mmCtx = miniMap.getContext('2d');
  miniMap.width = 150;
  miniMap.height = 150;

  function updateMiniMap() {
    mmCtx.clearRect(0, 0, miniMap.width, miniMap.height);
    mmCtx.fillStyle = 'rgba(0,0,0,0.5)';
    mmCtx.fillRect(0, 0, miniMap.width, miniMap.height);

    // Draw player as blue dot in center
    mmCtx.fillStyle = 'blue';
    mmCtx.beginPath();
    mmCtx.arc(miniMap.width/2, miniMap.height/2, 5, 0, Math.PI*2);
    mmCtx.fill();

    // Draw enemies relative to player
    enemies.forEach(enemy => {
      const dx = enemy.position.x - player.position.x;
      const dz = enemy.position.z - player.position.z;
      const scale = 3;
      const x = miniMap.width/2 + dx*scale;
      const y = miniMap.height/2 + dz*scale;
      if (x >= 0 && x <= miniMap.width && y >= 0 && y <= miniMap.height) {
        mmCtx.fillStyle = 'red';
        mmCtx.beginPath();
        mmCtx.arc(x, y, 4, 0, Math.PI*2);
        mmCtx.fill();
      }
    });
  }

  // Update health bar position
  function updateHealthBar(obj, barObj, maxHP) {
    if (!obj || !barObj) return;
    const pos = obj.position.clone();
    pos.y += 2.5;
    const vector = pos.project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
    barObj.container.style.transform = `translate(${x - 20}px,${y}px)`;
    const healthPercent = Math.max(0, obj.health / maxHP);
    barObj.bar.style.width = (healthPercent * 40) + 'px';
  }

  // Fireball shooting
  function shootFireball() {
    if (!player) return;
    // Calculate forward direction from camera/player
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(player.quaternion);
    const startPos = player.position.clone();
    startPos.y += 1.5;
    const fireball = new Fireball(startPos, forward);
    fireballs.push(fireball);
  }

  // Listen for space to shoot fireball
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      shootFireball();
    }
  });

  // Movement handling
  function handleMovement() {
    if (!player) return;
    const speed = 0.15;
    if (keys['w']) player.position.z -= speed;
    if (keys['s']) player.position.z += speed;
    if (keys['a']) player.position.x -= speed;
    if (keys['d']) player.position.x += speed;
  }

  // Update camera
  function updateCamera() {
    if (!player) return;
    camera.position.x = player.position.x;
    camera.position.z = player.position.z + 10;
    camera.lookAt(player.position.x, player.position.y, player.position.z);
  }

  // Water animation
  let waterTime = 0;
  function animateWater() {
    waterTime += 0.01;
    const posAttr = water.geometry.attributes.position;
    for(let i=0; i<posAttr.count; i++) {
      const x = posAttr.getX(i);
      const y = Math.sin(x * 2 + waterTime) * 0.1;
      const z = posAttr.getZ(i);
      posAttr.setY(i, y);
    }
    posAttr.needsUpdate = true;
    water.geometry.computeVertexNormals();
  }

  // Collision detection & combat
  function combat() {
    // Fireball hits enemies
    fireballs = fireballs.filter(fb => {
      const alive = fb.update();
      if (!alive) return false;
      // Check collision with enemies
      for (let enemy of enemies) {
        if (enemy.health <= 0) continue;
        const dist = fb.mesh.position.distanceTo(enemy.position);
        if (dist < 1) {
          enemy.health -= 20;
          fb.destroy();
          return false;
        }
      }
      return true;
    });

    // Player melee attack on close enemies (simple)
    enemies.forEach(enemy => {
      if (enemy.health <= 0) return;
      const dist = player.position.distanceTo(enemy.position);
      if (dist < 2) {
        // enemy attacks back
        playerHealth -= 0.1; // slow health drain for demo
        enemy.health -= 0.2; // player damages enemy when close
        if(playerHealth < 0) playerHealth = 0;
      }
    });
  }

  // Remove dead enemies
  function cleanEnemies() {
    enemies = enemies.filter(enemy => {
      if (enemy.health <= 0) {
        scene.remove(enemy);
        const idx = enemyHealthBars.indexOf(enemy);
        if(idx > -1){
          const bar = enemyHealthBars[idx];
          document.body.removeChild(bar.container);
          enemyHealthBars.splice(idx,1);
        }
        return false;
      }
      return true;
    });
  }

  // Update all health bars
  function updateHealthBars() {
    if(player) {
      updateHealthBar(player, playerHealthBar, playerMaxHealth);
      playerHealthBar.bar.style.backgroundColor = playerHealth > 60 ? 'green' : playerHealth > 30 ? 'orange' : 'red';
    }
    enemies.forEach((enemy, i) => {
      if(enemyHealthBars[i]) {
        updateHealthBar(enemy, enemyHealthBars[i], enemy.maxHealth);
      }
    });
  }

  // Game loop
  function animate() {
    requestAnimationFrame(animate);
    handleMovement();
    updateCamera();
    animateWater();
    combat();
    cleanEnemies();
    updateHealthBars();
    updateMiniMap();
    renderer.render(scene, camera);
  }

  animate();

  // Window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>

  
     
  
 
